// =================== MODELS ===================

// models/userModel.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
    name: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true, select: false },
    role: { type: String, enum: ['user', 'admin', 'donor', 'shopkeeper', 'institute'], default: 'user' },
    active: { type: Boolean, default: true },
    address: {
        street: String,
        city: String,
        state: String,
        pincode: String
    },
    createdAt: { type: Date, default: Date.now }
});

userSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();
    this.password = await bcrypt.hash(this.password, 12);
    next();
});

module.exports = mongoose.model('User', userSchema);

// models/donorModel.js
const mongoose = require('mongoose');

const donorSchema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    total_donations: { type: Number, default: 0 },
    last_donation_date: { type: Date }
});

module.exports = mongoose.model('Donor', donorSchema);

// models/shopModel.js
const mongoose = require('mongoose');

const shopSchema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, unique: true },
    shopName: { type: String, required: true },
    inventory: [{
        itemName: { type: String, required: true },
        quantity: { type: Number, required: true },
        pricePerUnit: { type: Number, required: true }
    }],
    contactInfo: {
        email: { type: String, required: true },
        phone: { type: String }
    },
    geolocation: {
        type: { type: String, default: "Point", enum: ["Point"] },
        coordinates: [Number]
    },
    verificationStatus: { type: Boolean, default: false },
    rating: { type: Number, default: 0 }
});

shopSchema.index({ geolocation: '2dsphere' });
module.exports = mongoose.model('Shop', shopSchema);

// models/instituteModel.js
const mongoose = require('mongoose');

const instituteSchema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, unique: true },
    institute_name: { type: String, required: [true, 'Institute name is required'] },
    institute_type: { type: String, required: true, enum: ['ORPHANAGE', 'ELDERLY_HOME', 'FOOD_PROVIDER'] },
    verification_status: { type: Boolean, default: true },
    verification_documents: { type: String },
    description: { type: String },
    geolocation: {
        type: { type: String, default: "Point", enum: ["Point"] },
        coordinates: { type: [Number], required: [true, "Coordinates are required"] }
    }
});

instituteSchema.index({ geolocation: '2dsphere' });
module.exports = mongoose.model('Institute', instituteSchema);

// models/requestModel.js
const mongoose = require('mongoose');

const requestSchema = new mongoose.Schema({
    institute: { type: mongoose.Schema.Types.ObjectId, ref: 'Institute', required: true },
    items: [{
        name: { type: String, required: true },
        quantity: { type: Number, required: true },
        unit: { type: String, required: true }
    }],
    category: { 
        type: String, 
        required: true,
        enum: ['FOOD', 'MEDICAL', 'EDUCATION', 'CLOTHING', 'OTHER']
    },
    priority: {
        type: String,
        enum: ['LOW', 'MEDIUM', 'HIGH'],
        default: 'MEDIUM'
    },
    status: { 
        type: String, 
        enum: ['pending', 'fulfilled'], 
        default: 'pending' 
    },
    comments: String,
    createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Request', requestSchema);

// models/donationModel.js
const mongoose = require('mongoose');

const donationSchema = new mongoose.Schema({
    donor: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    institute: { type: mongoose.Schema.Types.ObjectId, ref: 'Institute', required: true },
    shop: { type: mongoose.Schema.Types.ObjectId, ref: 'Shop', required: true },
    items: [{
        name: { type: String, required: true },
        quantity: { type: Number, required: true },
        unit: { type: String, required: true }
    }],
    totalAmount: { type: Number, required: true },
    status: { type: String, enum: ['pending', 'completed'], default: 'pending' },
    createdAt: { type: Date, default: Date.now }
});

donationSchema.path('items').schema.set('_id', false);
module.exports = mongoose.model('Donation', donationSchema);

// models/shippingModel.js
const mongoose = require('mongoose');
const geolib = require('geolib');

const shippingSchema = new mongoose.Schema({
    donation: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: 'Donation', 
        required: true 
    },
    qrCode: {
        type: String,
        unique: true,
        required: true
    },
    status: {
        type: String,
        enum: ['preparing', 'in-transit', 'delivered'],
        default: 'preparing'
    },
    deliveryProof: {
        photo: String,
        coordinates: {
            type: { type: String, default: "Point", enum: ["Point"] },
            coordinates: [Number]
        },
        timestamp: Date
    },
    createdAt: { type: Date, default: Date.now }
});

shippingSchema.index({ 'deliveryProof.coordinates': '2dsphere' });

shippingSchema.methods.verifyLocation = function(instituteCoords) {
    return geolib.isPointWithinRadius(
        { latitude: this.deliveryProof.coordinates[1], longitude: this.deliveryProof.coordinates[0] },
        { latitude: instituteCoords[1], longitude: instituteCoords[0] },
        120 // 120 meters radius
    );
};

module.exports = mongoose.model('Shipping', shippingSchema);

// =================== CONTROLLERS ===================

// controllers/authController.js
exports.protect = catchAsync(async (req, res, next) => {
    // 1) Check if token exists
    let token;
    if (req.cookies.jwt) {
        token = req.cookies.jwt;
    }

    if (!token) {
        return next(new AppError('You are not logged in! Please log in to get access.', 401));
    }

    // 2) Verify token
    const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);

    // 3) Check if user still exists
    const currentUser = await User.findById(decoded.id);
    if (!currentUser) {
        return next(new AppError('The user belonging to this token no longer exists.', 401));
    }

    // GRANT ACCESS TO PROTECTED ROUTE
    req.user = currentUser;
    next();
});

exports.restrictTo = (...roles) => {
    return (req, res, next) => {
        if (!roles.includes(req.user.role)) {
            return next(new AppError('You do not have permission to perform this action', 403));
        }
        next();
    };
};

// controllers/userController.js
exports.updateMe = catchAsync(async (req, res, next) => {
    // 1) Create error if user POSTs password data
    if (req.body.password || req.body.passwordConfirm) {
        return next(new AppError('This route is not for password updates. Please use /updateMyPassword.', 400));
    }

    // 2) Filter unwanted fields
    const filteredBody = filterObj(req.body, 'name', 'email', 'address');

    // 3) Update user document
    const updatedUser = await User.findByIdAndUpdate(req.user.id, filteredBody, {
        new: true,
        runValidators: true
    });

    res.status(200).json({
        status: 'success',
        data: {
            user: updatedUser
        }
    });
});

exports.getMe = catchAsync(async (req, res, next) => {
    const user = await User.findById(req.user.id);
    
    res.status(200).json({
        status: 'success',
        data: {
            user
        }
    });
});

// controllers/instituteController.js
exports.createInstitute = catchAsync(async (req, res, next) => {
    const institute = await Institute.create({
        user: req.user.id,
        institute_name: req.body.institute_name,
        institute_type: req.body.institute_type,
        description: req.body.description,
        geolocation: req.body.geolocation
    });

    res.status(201).json({
        status: 'success',
        data: {
            institute
        }
    });
});

exports.getInstitute = catchAsync(async (req, res, next) => {
    const institute = await Institute.findOne({ user: req.user.id })
        .populate('user', 'name email address');

    if (!institute) {
        return next(new AppError('No institute found for this user', 404));
    }

    res.status(200).json({
        status: 'success',
        data: {
            institute
        }
    });
});

exports.updateInstitute = catchAsync(async (req, res, next) => {
    const institute = await Institute.findOneAndUpdate(
        { user: req.user.id },
        req.body,
        {
            new: true,
            runValidators: true
        }
    );

    if (!institute) {
        return next(new AppError('No institute found for this user', 404));
    }

    res.status(200).json({
        status: 'success',
        data: {
            institute
        }
    });
});

// controllers/shopController.js
exports.createShop = catchAsync(async (req, res, next) => {
    const shop = await Shop.create({
        user: req.user.id,
        shopName: req.body.shopName,
        contactInfo: req.body.contactInfo,
        geolocation: req.body.geolocation
    });

    res.status(201).json({
        status: 'success',
        data: {
            shop
        }
    });
});

exports.updateInventory = catchAsync(async (req, res, next) => {
    const shop = await Shop.findOne({ user: req.user.id });

    if (!shop) {
        return next(new AppError('No shop found for this user', 404));
    }

    shop.inventory = req.body.inventory;
    await shop.save();

    res.status(200).json({
        status: 'success',
        data: {
            shop
        }
    });
});

exports.getNearbyShops = catchAsync(async (req, res, next) => {
    const { coordinates, maxDistance = 5000 } = req.query;

    const shops = await Shop.find({
        geolocation: {
            $near: {
                $geometry: {
                    type: 'Point',
                    coordinates: coordinates.map(Number)
                },
                $maxDistance: maxDistance
            }
        }
    });

    res.status(200).json({
        status: 'success',
        results: shops.length,
        data: {
            shops
        }
    });
});

// controllers/donorController.js
exports.createDonation = catchAsync(async (req, res, next) => {
    const { instituteId } = req.params;
    const { items, shopId, totalAmount } = req.body;

    // Verify institute exists
    const institute = await Institute.findById(instituteId)
        .populate('user');
    if (!institute) {
        return next(new AppError('Institute not found', 404));
    }

    // Verify shop exists
    const shop = await Shop.findById(shopId)
        .populate('user');
    if (!shop) {
        return next(new AppError('Shop not found', 404));
    }

    // Create donation
    const donation = await Donation.create({
        donor: req.user.id,
        institute: instituteId,
        shop: shopId,
        items,
        totalAmount
    });

    // Generate QR code for delivery verification
    const qrCodeData = await shippingController.generateDeliveryQR(donation._id);

    // Send email to institute with QR code
    await new Email(institute.user, {
        instituteName: institute.institute_name,
        items,
        totalAmount,
        qrCodeData
    }).sendDonationNotificationWithQR();

    // Send email to shop
    await new Email(shop.user, {
        shopName: shop.shopName,
        instituteName: institute.institute_name,
        instituteAddress: institute.user.address,
        items,
        totalAmount
    }).sendShopDeliveryNotification();

    res.status(201).json({
        status: 'success',
        data: {
            donation
        }
    });
});

exports.getShopsWithRequestedItems = catchAsync(async (req, res, next) => {
    const { instituteId } = req.params;

    // Get institute's active request
    const request = await Request.findOne({
        institute: instituteId,
        status: 'pending'
    });

    if (!request) {
        return next(new AppError('No active request found for this institute', 404));
    }

    // Find shops that have all requested items in inventory
    const shops = await Shop.find({
        'inventory.itemName': {
            $all: request.items.map(item => item.name)
        }
    });

    res.status(200).json({
        status: 'success',
        data: {
            request,
            shops
        }
    });
});

// controllers/requestController.js
exports.getAllRequests = catchAsync(async (req, res, next) => {
    let filter = {};

    if (req.user.role === 'institute') {
        const institute = await Institute.findOne({ user: req.user.id });
        filter = { institute: institute._id };
    }

    const requests = await Request.find(filter)
        .populate({
            path: 'institute',
            populate: { path: 'user', select: 'name email address' }
        });

    res.status(200).json({
        status: 'success',
        results: requests.length,
        data: {
            requests
        }
    });
});

exports.getRequest = catchAsync(async (req, res, next) => {
    const request = await Request.findById(req.params.id)
        .populate({
            path: 'institute',
            populate: { path: 'user', select: 'name email address' }
        });

    if (!request) {
        return next(new AppError('No request found with that ID', 404));
    }

    res.status(200).json({
        status: 'success',
        data: {
            request
        }
    });
});

exports.getRequestWithShops = catchAsync(async (req, res, next) => {
    const request = await Request.findById(req.params.id)
        .populate('institute');

    if (!request) {
        return next(new AppError('No request found with that ID', 404));
    }

    // Find nearby shops with matching inventory
    const shops = await Shop.find({
        geolocation: {
            $near: {
                $geometry: request.institute.geolocation,
                $maxDistance: 5000 // 5km radius
            }
        },
        'inventory.itemName': {
            $in: request.items.map(item => item.name)
        }
    });

    res.status(200).json({
        status: 'success',
        data: {
            request,
            shops
        }
    });
});

// controllers/shippingController.js
const Shipping = require('../models/shippingModel');
const Donation = require('../models/donationModel');
const Institute = require('../models/instituteModel');
const Shop = require('../models/shopModel');
const Email = require('../utils/email');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');
const QRCode = require('qrcode');
const { v4: uuidv4 } = require('uuid');

exports.generateDeliveryQR = catchAsync(async (donationId) => {
    const qrCode = uuidv4();
    const qrImageData = await QRCode.toDataURL(qrCode);
    
    await Shipping.create({
        donation: donationId,
        qrCode
    });

    return qrImageData;
});

exports.verifyDelivery = catchAsync(async (req, res, next) => {
    const { qrCode } = req.params;
    const { photo, coordinates } = req.body;

    // Find shipping record
    const shipping = await Shipping.findOne({ qrCode })
        .populate({
            path: 'donation',
            populate: [
                { path: 'institute' },
                { path: 'shop' }
            ]
        });

    if (!shipping) {
        return next(new AppError('Invalid QR code', 400));
    }

    // Verify shopkeeper
    if (shipping.donation.shop.user.toString() !== req.user.id) {
        return next(new AppError('You are not authorized to deliver this donation', 403));
    }

    // Verify location
    const instituteCoords = shipping.donation.institute.geolocation.coordinates;
    const isValidLocation = shipping.verifyLocation(instituteCoords);

    if (!isValidLocation) {
        return next(new AppError('Delivery must be within 120 meters of institute', 400));
    }

    // Update shipping record
    shipping.status = 'delivered';
    shipping.deliveryProof = {
        photo,
        coordinates: {
            type: 'Point',
            coordinates: coordinates
        },
        timestamp: Date.now()
    };

    await shipping.save();

    // Update donation status
    await Donation.findByIdAndUpdate(shipping.donation._id, { status: 'completed' });

    // Send confirmation emails
    await new Email(shipping.donation.institute.user).sendDeliveryConfirmation(shipping);

    res.status(200).json({
        status: 'success',
        data: { shipping }
    });
});

// email/donationNotificationWithQR.pug
doctype html
html(lang="en")
  head
    meta(charset="UTF-8")
    meta(name="viewport" content="width=device-width, initial-scale=1.0")
    title New Donation Received
  body(style="font-family: Arial, sans-serif; padding: 20px;")
    div(style="max-width: 600px; margin: 0 auto;")
      h1 New Donation Received
      
      p Dear #{instituteName},
      
      p A new donation has been made:
      
      ul
        each item in items
          li #{item.quantity} #{item.unit} of #{item.name}
      
      p Total Amount: ₹#{totalAmount}
      
      div(style="text-align: center; margin: 20px 0;")
        img(src=qrCodeData alt="Delivery QR Code" style="width: 200px;")
        p Please scan this QR code when the delivery arrives
      
      p The shopkeeper will need to:
      p 1. Be within 120 meters of your location
      p 2. Scan this QR code
      p 3. Take a photo of the delivered items
      
      p Best regards,
      p The Team

// email/shopDeliveryNotification.pug
doctype html
html(lang="en")
  head
    meta(charset="UTF-8")
    meta(name="viewport" content="width=device-width, initial-scale=1.0")
    title New Delivery Request
  body(style="font-family: Arial, sans-serif; padding: 20px;")
    div(style="max-width: 600px; margin: 0 auto;")
      h1 New Delivery Request
      
      p Dear #{shopName},
      
      p Please prepare the following items for delivery:
      
      ul
        each item in items
          li #{item.quantity} #{item.unit} of #{item.name}
      
      p Delivery Instructions:
      ol
        li Go to the institute location
        li Be within 120 meters of the institute
        li Scan the QR code provided to the institute
        li Take a photo of the delivered items
      
      p Institute Details:
      p Name: #{instituteName}
      p Address: #{instituteAddress}
      
      p Total Amount: ₹#{totalAmount}
      
      p Best regards,
      p The Team 

// routes/shippingRoute.js
const express = require('express');
const shippingController = require('../controllers/shippingController');
const authController = require('../controllers/authController');

const router = express.Router();

router.use(authController.protect);

router.post(
    '/verify-delivery/:qrCode',
    authController.restrictTo('shopkeeper'),
    shippingController.verifyDelivery
);

module.exports = router; 